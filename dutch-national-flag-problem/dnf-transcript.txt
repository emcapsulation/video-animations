YOUTUBE

Scene 1
If you have an array of elements and you need to sort them in ascending order, it is well known that this can be done in O(nlogn) time, with a sorting algorithm like merge sort for example.

But what if you knew that the elements of this array were constrained to only being one of three unique elements?

Actually, there is a way to now sort this in linear O(n) time.

This is known as the Dutch National Flag problem. It sorts an array in O(n) time and using only constant O(1) extra space. In other words, it can sort the array in place and in linear time.

The constraint is that all the elements in the array take on one of three distinct values.

Amazingly, it was proposed by Dijkstra, the same Dijkstra who created the famous shortest path algorithm.

The reason it's named that way is because the Dutch National Flag has only three colours, red, white and blue, so the problem was originally proposed as arranging balls of these colours in the order of the stripes on the flag.

Scene 2
The algorithm consists of three pointers, which we will call low, mid and high. 

We start low and middle pointing to the first index of the array. And high points to the last index of the array.

While the mid pointer is less than or equal to the high pointer:
1. If the value at mid is equal to the value of the middle element, we increment it.
2. If the value at mid is greater than the value of the middle element, we swap the elements at mid and high. Then we decrement high.
3. If the value at mid is less than the value of the middle element, we swap the elements at low and mid. Then we increment both.

Scene 3
Let's look at a larger example. These are students and their test scores. Say below 50 is a fail, between 50 and 85 is a pass, and 85 and above is a pass with honours. Now we want to rank the students purely based on these groupings.

You could be thinking "we could create three separate lists for each grade and add the students to these lists". But part of the appeal of the aforementioned three-pointer approach is that we can actually sort the list of these students in place. Meaning we don't need to waste any time or memory creating new lists and moving elements between lists.

So let's run through Dijkstra's three pointer algorithm on this list of students.

Scene 4
You've seen a few examples now, so you can probably start to see why it works. Essentially, the low pointer keeps track of the end of the first group. The middle pointer tracks the end of the middle group. And the high pointer keeps track of the start of the high group. 

That is also why the swapping works. Because if the value pointed to by the mid pointer is less than the middle element, you put it in the low category. If the value is greater than the middle element, you put it in the high category.

Therefore, the algorithm ends when the middle and high pointers meet, because the end of the middle group lines up with the start of the high group.

Scene 5
Coding