YOUTUBE

Scene 1
Here I have an array of elements, and I need to sort them in ascending order.

It's well known that this can be done in O(nlogn) time, with a sorting algorithm like merge sort for example.

Scene 2
But what if you knew that the elements of this array were constrained to only being one of three unique elements?

Actually, there is a way to now sort this in linear O(n) time.

Scene 3
This is known as the Dutch National Flag problem. It sorts an array in O(n) time and using only constant O(1) extra space. In other words, it can sort the array in place and in linear time.

The constraint is that all the elements in the array are one of three distinct values.

Amazingly, it was proposed by Dijkstra, the same Dijkstra who created the famous shortest path algorithm.

The reason it's named that way is because the Dutch National Flag has only three colours, red, white and blue, so the problem was originally proposed as arranging elements of these colours in the order of the stripes on the flag.

Scene 4
The algorithm consists of three pointers, which we will call low, middle and high. 

We start low and middle pointing to the first index of the array. And high points to the last index of the array.

While the middle pointer is less than or equal to the high pointer:
1. If the value at middle is equal to the value of the mid element, we increment it.
2. If the value at middle is greater than the value of the mid element, we swap the elements at middle and high. Then we decrement high.
3. If the value at middle is less than the value of the mid element, we swap the elements at low and middle. Then we increment both.

Scene 5
Let's look at a larger example. These are students and their test scores. Say below 50 is a fail, between 50 and 85 is a pass, and 85 and above is a pass with honours. Now we want to rank the students purely based on these groupings.

You could be thinking "we could create three separate lists for each grade and add the students to these lists". But part of the appeal of the aforementioned three-pointer approach is that we can actually sort the list of these students in place. Meaning we don't need to waste any time or memory creating new lists and moving elements between lists.

So let's run through Dijkstra's three pointer algorithm on this list of students.

Scene 6
You've seen a few examples now, so you can probably start to see why it works. Essentially, the low pointer keeps track of the end of the first group. The middle pointer tracks the end of the middle group. And the high pointer keeps track of the start of the high group. 

Therefore, the algorithm ends when the middle and high pointers meet, because the end of the middle group lines up with the start of the high group.