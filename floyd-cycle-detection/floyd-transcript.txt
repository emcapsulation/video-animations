Scene 1
This is a linked list. The data is stored in nodes, and each node also contains a pointer to the next node. Unlike an array, the data is not stored in a contiguous memory block, so you cannot access say the nth node by its index. Instead, you have to traverse the linked list to search for the node you want, and stop traversing if the next node is null, indicating we've reached the tail.

Scene 2
But a problem is encountered when your linked list has a cycle. There is no clear stopping point, because the next node is never null. Using the same code as for the previous case, your pointer will keep moving around and around the cycle in an infinite loop. So it can be beneficial to be able to detect a cycle first.

Scene 3
The standard way is to keep track of all visited nodes in a set. Each time you visit a node, you first check if it is in the set. If not, add it and move to the next node. If the next node is null then there is no cycle and we can exit. If we reach a node that is in the set, then we can also exit but we know there must be a cycle, so we can return that node as the start of the cycle.

Scene 4
This approach's time complexity is O(n) because for each node we are only performing a constant time lookup in the set. Where we can do better is the space complexity, which is also O(n). See, the size of the set grows linearly with the size of the linked list. Is there a way to do this with constant space?

Scene 5
Floyd's Cycle Finding algorithm uses only two pointers: A slow pointer (tortoise), which traverses the linked list one node at a time. And a fast pointer (hare), which moves two nodes at a time, so it is moving twice as fast as the tortoise. If there is no cycle, the hare will simply reach the tail of the linked list. So in that case you can stop and return that there is no cycle.

Scene 6
But if there is a cycle, the hare will race away from the tortoise, then catch up to it around the cycle part of the linked list. If the hare catches up to the tortoise, you can say there is a cycle in the linked list. 

But this algorithm has one more trick: It can find where the cycle begins. Once the two pointers meet, bring the tortoise back to the head of the linked list. Then step both pointers through one at a time - They will meet at the start of the cycle!

Scene 7
I think it is quite intuitive as to why the hare, moving two nodes at a time, will meet up with the tortoise which is moving only one node at a time, around a cycle. 

Scene 8
But what is less intuitive is why taking one of the pointers back to the start, and stepping them through one node at a time, has them meet at the entry point of the cycle. Let's look at why now.

We want to show that when we take one pointer back to the start and step it through one at a time, that the distance to the start of the cycle (x), is equal to the distance covered by the other pointer, which is some number of loops of the cycle (nL) plus that little piece from the meeting point to the start of the cycle (z).
