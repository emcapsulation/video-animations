YOUTUBE

Scene 1
This is a flow network. You have a source node where flow is emanating from, and a sink node where the flow will reach. 

Nodes are joined with weighted directed edges, where each edge weight defines the maximum flow (or capacity) which can be sent through this edge.

Each edge starts off empty, with 0 units of flow.

Typically in flow networks, the challenge is to find: If we push flow through these edges, what is the maximum flow that can reach the sink?


Scene 2
In this video we will first cover useful flow network properties. 

Then we will do a walkthrough of the Ford Fulkerson method for finding the max flow. 

We will then do a larger example. 

We will then code this with the Edmonds-Karp implementation in C++.

Finally we will go through max-flow min-cut theorem. 

So stay tuned, and feel free to skip to the relevant parts of the video if you already know some of this stuff.


Scene 3
Flow networks have a source node where flow is emanating from, and a sink node where flow will terminate.

Nodes are joined with weighted directed edges, where each edge weight defines the capacity of that edge, i.e. the max number of flow units which can be sent through that edge.

Let's look at the paths in this network. Imagine these are pipes or roads.

Our first constraint is: All edges in the graph can only carry a flow which is less than or equal to its capacity.

In the top path, we could push 5 units of flow through the first edge. But then the second edge only has a capacity of 3. So only 3 units of flow can possibly be carried through that edge. 

This means the total amount of flow which can reach the sink from this top path, is actually reduced to 3. 

Edges which cap the flow of a path in this way, are called bottlenecks. The bottleneck is the edge which can carry the least amount of flow in a particular path, because it restricts the flow of the entire path.

So let's update the first edge in this path to be 3.

Because our second property is: For all nodes other than the source and sink, the flow into the node must equal the flow out.

In the bottom path, we can push 2 units of flow through the first edge. Even though the second edge has a capacity of 4, only 2 units of flow entered it from the first edge. So it will simply transport these 2 units of flow to the sink.

In the bottom path, the edge with weight 2 is the bottleneck, being the edge with the smallest capacity in the path.

Under these contraints, the network flow is the the sum of the flows which entered the sink (or left the source). In this case that's 3 + 2 - which is 5. In this example 5 is also the max flow which can reach the sink.


Scene 4
It begs the question - How do we find this max flow programmatically?

You might think based on the previous example we could just:
Keep finding paths from s to t.
1. Find the bottleneck of the path
2. Push the maximum flow we can through each path, capped by the bottlenecks
Then return the flow as the maximum flow.

For example in this case you might think - the bottlenecks of the top and bottom paths are 3 and 2 respectively, so push 3 and 2 units of flow through these paths to get the max flow value of 5.


Scene 5
But let me show you an example where this approach fails.

Here is a path. The bottleneck is 1. Let's push 1 unit of flow through this path. 

Let's look for another path. Here is one. The bottleneck capacity is 1 because the second edge only has room for one more unit of flow to be pushed through it. So let's push one unit of flow through this path.

Now there are no more paths left from s to t. So the maximum flow is returned as the sum of the flows leaving the source or the sum of the flows entering the sink - 2 in this case.

But this is the wrong answer.

If we consider these two paths, we can see the maximum flow is actually 3. So the greedy algorithm fails because it depends on the order of paths you choose.


Scene 6

Ford Fulkerson addresses this problem by making one tweak - after we push the flow through a path, we then insert a back edge for each edge in the path, and we set the capacity of this new back edge to be the flow we just pushed. 

This means we have the chance to correct our flow if we saturate an edge and leave ourselves with no paths left. Because we all make mistakes.

Let's walk through the algorithm.
1. Initialise the flow on all edges to 0.

2. While there is a path p from source to sink in the network:

2. a. Find the bottleneck capacity of the path. In this case, the bottleneck is 1.

2. b. Send a flow equal to the bottleneck through all edges in the path. We push 1 unit of flow through these edges.

2. c. And now here's the extra step - for each edge in the path, draw a back edge whose capacity is the flow sent through that edge. 
In other words, the capacity of these backward edges will be 1.

This just gives you a chance to backtrack the flow on this edge in future iterations. Think of these back edges as giving you the ability to take away flow from this path, and move it to another path.

Let's keep looking for paths until we run out. Here is another one - bottleneck capacity is 1. Push 1 unit of flow through this path.

Note that the flow through the second edge is 2 now, so we need to update the capacity of the back edge to 2. This is because we can correct up to two units of flow now.

And draw the back edge for that first edge in the path, with a capacity of 1 since the flow is 1 through that edge.

There is another path here. Can you see it? Yes we can now take the back edge.

We can push 1 unit of flow through this path. 

Note that when we push 1 unit of flow through the back edge, we take away flow on the forward edge.

Now backtrack and update the back edge capacities to match the new flows.

The important thing to remember is for all nodes other than the source and sink, the flow into a node equals the flow out.

Now there are no more paths from s to t. So the final flow is our max flow.


Scene 6
Let's do the example we saw at the very beginning.

Firstly look for a path from s to t. This looks like a good one.

Find the bottleneck capacity of this path, which is the edge which restricts your flow in this path. In this case it is 5 because 5 is the smallest amount of flow we can send through any edge in this path.

Send an amount of flow through the path equal to the bottleneck capacity.

For each edge in the path, we create back edges. The capacity of a back edge is equal to the flow sent through that edge.

In this case the capacity of all these back edges is 5.

You might hear this referred to as building the residual graph - This just means we are allowing ourselves to backtrack on the flow we've assigned by drawing in back edges.

Let's choose this top path this time.

The bottleneck capacity here is 4 because this second edge can only carry 4 more units of flow.

Let's push 4 units of flow through this path.

Now we insert the back edges, with capacities equal to the flows of the edges. The back edge on the second edge of the path needs to have its capacity updated to 9 because the flow of this edge is 9 now.

This first edge has a back edge of capacity 4.

Now let's choose this bottom path. The bottleneck is 4, caused by the first edge. Let's send through 4 units of flow. And create the back edges.

There is one more path, we can take this one through one of the back edges. The bottleneck of this path is 3, so let's push 3 units of flow through.

Remember, when we push 3 units through the back edge, we take away 3 units of flow on the forward edge.

Now backtrack and update the back edge capacities to match the new flows. The first back edge needs to have its capacity updated to 7. This back edge has capacity 3, capacity 2 now, and capacity 7.

There are no more paths from s to t, so let's return this flow as the max flow. The flow is the sum of the flows leaving the source, or the sum of the flows entering the sink. That is 9 plus 7 which is 16. 


Scene 7
Time to code I reckon. 

The algorithm we will be coding is the Edmonds-Karp implementation of Ford-Fulkerson.

You might be thinking who are these guys. Well Ford-Fulkerson simply says to find the augmenting paths, but doesn't specify how. 

So if you want to code it, you need a way to actually find the paths.

Edmonds-Karp simply says "Let's use a BFS to find the augmenting paths". BFS being a breadth first search.



