Scene 1
In a previous video, we made a terminal snake game in under 50 lines of Python code using the curses library. But our snake is lonely. He's been chasing and eating food by himself for too long which is kinda sad.

Let's give him some mates by turning this snake game multiplayer. At the same time we will take a deep dive into socket programming in Python.

We are going to be making this multiplayer snake game together. 

However, slight disclaimer - This tutorial assumes you already know a bit of Python. I won't be explaining every line or we'll be here until Python 4 is released. But I will definitely walk you through the important concepts around networking and threads.

So let's dive right in!


Scene 2
Before we write a single line of code, let's go through the basic architecture of how multiplayer games work.

A multiplayer game is essentially a distributed system. Players on separate machines will interact with a shared world which needs to stay synchronised for everybody. Or someone's snake might start teleporting.

To make that happen, all clients (the players' computers) will connect to a server, which will act as the source of truth for the game state. Each client will send updates to the server, like "Hey, I pressed the W key, move my snake upwards!" Or "Hey I just joined, here is my username!"

The server gathers these messages from every connected player, and updates the game state accordingly - "ok, your snake is now moving upwards!" "And, some other guy ate the food, increment his score". Then it will broadcast this new game state out to every client.

Each client is running a loop that continually receives these updates from the server. Each time it receives the new game state, it renders it to the screen so the player sees the latest version of the world.


Scene 3
Inside your game directory, create two folders - server and client.

Inside server we will make a new file called server.py. And import the socket library.


Scene 4
But what is a socket? I'm glad you asked.

A socket is an endpoint in a communication stream, allowing a program to send and receive data over a network. You can read from it, and write to it, just like you would a file. But instead of reading from disk, you are reading and writing bytes over a network.

In IP networking, a socket is identified by three parts:
- The IP address - which machine are we talking to? 
- The port number - which specific app or service on that machine?
- And the protocol (usually TCP or UDP), which determines how the data is transmitted.

Then when two sockets connect, they form a channel where both sides can send and receive data. This connection is uniquely described using a 5-tuple which includes: the source IP and port, destination IP and port, and the protocol being used.


Scene 5
Then this is the typical plotline:

We create a server socket, and we bind this server socket to the host and port. Basically - this is my address, come find me here.

We then call listen on the server socket to mark it as a passive socket. That means it's not initiating connections, but it is waiting to accept them from clients.

On the client side, we also create a socket object. But instead of waiting, we call connect to initiate a connection to the server.

The server accepts the incoming connection. This returns a new socket object, conn, dedicated to exclusively communicating with that particular client. 

Meanwhile, the original server socket continues to listen for more connections. 

This conn socket is where the talking happens.

Until of course, they close their sockets. Like a breakup.


Scene 6
Before we dive into creating the server, I made a log_message function in a file called logging_utils.py. 

This is completely optional, as this is purely for outputting logs to the screen in a nice format and making the console feel important, but I will put the code here anyway. If you hate amazing logging feel free to just use print I guess I won't stop you.


Scene 7
Now onto the good stuff - in server.py, create your new Server class. Mine is set up with that logging function.

In the __init__, we want to pass in the host IP and the port. Then create the socket with socket (the library) dot socket. AF_INET means we are using IPv4 addresses, and SOCK_STREAM means our protocol will be TCP. 

TODO: Show on screen "IPv4" and "TCP"

TCP and other protocols is a topic in itself - out of scope for us today. But a brief summary is that TCP ensures reliabile, ordered, error-checked packet delivery. So our game won't have random glitches or missing snake moves.

Earlier I said a socket is defined by three things. Well now we've caught all three pokemon - host, port and protocol.

In the main function I will make the host 127.0.0.1 - This is the loopback interface and just means it will only accept connections from the same machine right now. 

So at this point, the server and client will both be running on your laptop which is great for testing. But don't worry, later I will show you how to set this up so other computers can connect to you.

The port is 5050 - doesn't matter, it can be basically anything in the registered port range (lots of options). 

Then of course initialise the server.


Scene 8
Let's define the start method. 

TODO: Put up the server socket animation on the side

First we bind the socket to the host and port by passing in the (self.host, self.port) tuple. Then listen() for incoming connections, putting our server in the chill and wait for friends mode. Let's print this nice log message to the screen.

And don't forget to actually call the method. I've been there a few times. "Why's it not working!"

TODO: cmd for Windows, terminal, etc.

Let's give it a spin by cd-ing to your server directory, and running with python3 server.py. Or python, py, whatever your machine insists on. It's alive.


Scene 9
Before we venture further and make it actually accept incoming connections, we should create a close method so we can free up the address once we're done. Otherwise you might get this address already in use error which is annoying.

TODO: Red background

For now we just close the server listening socket with .close(). And call this under server.start(), to clean things up at the end.

Of course we need to accept these connections. Our accept code will go in a while True so that we keep accepting connections until we CTRL+C outta there. 

So this loop should go inside a try block, and except KeyboardInterrupt. And finally close everything using that flashy new close method.  

TODO: Text - I say accept and except the same.

TODO: Put this text on the screen

A quick note on this spicy error handling:
- Try is the block of code to be run.
- except is where we handle the error or signal.
- finally is run when the block of code ends, regardless of whether an exception was caught.

In this case, we want to call close when the loop ends, regardless of whether it ended nicely or with an exception. It doesn't care about your past.

Quick heads up for Windows users, CTRL+C won't always stop the server in the terminal. Because accept() is a blocking call which Windows struggles to interrupt cleanly with a KeyboardInterrupt. So you can cry into your task manager.


Scene 10
Let's accept the connections. This accept method returns two things: Conn is the socket dedicated to communicating with this particular client that just connected, and address is the IP and port of the client, so we know who just rang the doorbell.

So why do we have conn? This is a new socket object for chatting to this particular client, so our listen socket (self.socket) can still listen for other clients too.

Let's run it - it's just sitting there listening but unfortunately no one is showing up to its party just yet.

You can actually connect to it with netcat if you are on Linux. Let's connect to our host (127.0.0.1) and port (5050). 

And check out the server logs - New client connected!

If you are on Windows don't lose sleep because we are about to code the client.


Scene 11
TODO: Client animation here

Let's make some guests show up. In the client directory, create a new file called client.py make a Client class. 

This host, port and socket initialisation should feel like deja vu. But this time host and port will be the address of the server socket we want to connect to. Remember the client is going to reach out to the server's socket.

TODO: Text - server address, client's own socket

Over in our main function, when we start the client.py program let's give the user the ability to input the server IP address. Because the server could be run on any machine - yours, mine, that one guy in your discord chat - we want to connect to whichever machine is running the server. Then the port is 5050.

And initialise the Client with this server IP and port!

Once again we need a start function. But this time instead of calling listen like the chill guy server, the client is a bit more proactive and will connect to the server host and port. He's more like your extraverted friend.

Then we also want a close method. Again let's just close our socket for now with self.socket.close(), but in the future we will include other cleanup in here. I like to pass a message into here just to print to the screen why we closed it. 

Now back in our start method, if the connect raised an exception, we'll catch it and call our close method with the message we couldn't connect to the server. Otherwise (or else) let's print that we connected to the server.

This is the other exception handling flow - else only runs if an exception was NOT caught, whereas finally runs regardless.

Again remember to call start and close in your main function.


Scene 12
Let's give this a whirl. For this, open a second terminal and navigate to the client directory.

Firstly, if I try connecting with the client and the server isn't running, it says hey couldn't connect. Our error handling is doing its job.

Now when we run the server, then start the client, you can see the server accepted the connection from the client and the client shows successfully connected.

But the client quits immediately. Why? Because we are doing nothing once connected, so the program just ends. There's no loop, no sending or receiving data, it's like the client shows up, rings the doorbell then goes home.


Scene 13
TODO: Flash up the ports

You also might have noticed something a bit odd. Every time a client connects, it comes from a different port number - what's up with that? 

Remember how earlier in the video I said our server port needed to be in the registered port range? Well client ports don't need to be fixed. So my OS is actually assigning the client socket a random port from the ephemeral or dynamic port range - we don't need to choose it.


Scene 14
Anyway, back in server.py you see we get conn, which from earlier (quick refresher) is our new socket object for communicating with this client. Give yourself a pat on the back because you've essentially finished the initial set up!

But how can we communicate with this client, whilst still accepting new connections in the while loop?

The answer is we actually handle reading and writing to conn on a separate thread. But what is a thread? I'm glad you asked.

A thread is an execution unit within a process. Think of each thread as a worker with their own task to complete. If I spin up a new thread, I can give it its own set of instructions. But the key thing is it still shares memory and CPU time with the other threads in that process. 

As an analogy, it's like the threads are cutting different veggies but adding to the same salad. They have their own task, but are working with the same set of ingredients and equipment.

The CPU switches really quickly between these threads, giving the appearance that they are running at the same time.

This helps us immensely because when the server accepts a new client, we can start a new thread just for sending and receiving data for that connection. 

Meanwhile the main thread is still listening for and accepting new clients at the same time!


Scene 15
Let's do it. 

Firstly, create a new Connection class to manage a client connection in your server directory. I see a lot of tutorials put all this stuff in the one server file. But trust me, future you will thank you for having clean code - debugging messy socket code with threads is one way to speedrun wanting to quit programming.

In the __init__, pass in:
- The conn socket, the one that is tied to this particular client.
- And the client's address. 
In the near future the user will send across their username too so let's get ready for that with self.username = None.

Guess what method we want - that's right, close. Again just close the socket. But calling close on any instance of the Connection class will only close the socket associated with communicating with this particular client (conn). The server still has its listener socket open.

In server.py import threading and the Connection class. Then initialise a new Connection instance with the socket and address returned by .accept().

Now here is where the magic happens. We are going to handle the connection - but in a separate thread: threading.Thread

target= tells the thread which function to run when it starts. We are going to run a method in our Connection class called handle, which is a task for future us to write that method.

Then use daemon=True - This essentially makes it a background thread. So when the main program ends, these threads won't hang around to keep finishing their tasks, they'll automatically shut down with the program.

Not the most graceful shutdown plan, but for now we're just building the house without worrying about the curtains.

Then of course back in our Connection class we need to actually make that handle method. For now, let's just log a debug message to the screen. In the future it will receive messages from the client.

If we connect to the server now from the client, you can see it says new client connected, then handle method called.


Scene 16
At the moment handle is awkwardly standing around doing nothing, but that's about to change. When a client first connects, they should send across their username! Let's do it.

In client.py, we want to make a send method for sending a message to the server. 

sendall() will ensure the full message is sent. And we need to convert the message to bytes because sockets don't speak Python strings - we can do this with encode. Finally, I finish the message with the newline character (as a byte) to denote the end of the message. It's like socket punctuation.

If we couldn't send the message let's close the socket.

Sending the username should be the first thing that happens when the client first connects, so let's call the send_username method here right after we connect to the server.

Inside send_username, prompt the player to enter their username. Then we will send over this username dictionary using our flashy new send method. But make sure to convert this to a string with json.dumps.

You might be wondering - why not just send the username? Why have this dictionary? It's because the server will be receiving many messages from many clients. So when you send across Snakeguy as your username, you need to actually tell the server that this is a username so it can handle it accordingly.

Over in Connection, import traceback for some informative error messages when the thing craps itself.

Then in our handle method, the first thing this Connection object will do is receive the username. If not, spew out the stack trace.

Of course, once handle is done, close the connection. Remember this is only closing this conn socket. This won't close your server down.

In receive_username, we will read 1024 bytes from the socket with self.socket.recv(1024). Or 2 to the power of 10 for the maths nerds. Convert these bytes back to a string with decode which is like encode's friendly twin. And remove that newline char with strip.

Raise an exception if we received nothing - that probably means the client closed their program before sending a username. Otherwise let's print out what we got. 

Let's take a look. I'll send across my username - Yep, the server has received our new username!


Scene 17
So far we've been sending messages like pros with json.dumps + encode. Now it's time to unwrap that message on the server side with decode + json loads to get the dictionary back. Like wrapping and unwrapping a present.

Let's create a new method in our Connection class called parse_message, for converting the messages from the client back to an object with json.loads.

import json. Then try and convert the received message to a JSON dict with json.loads. If that didn't work out, log the stacktrace. Finally, return the parsed_message (which will be None if the parse failed).

Now we have our username_json.

But what do we want to do with these message objects that come in? Well we want the server to handle them. The clients are basically yelling things like "Here is my username!", "I moved my snake!", "I quit the game!" and so the server needs to update the game state accordingly.

To manage all this yelling we are going to create a message queue. Think of it like a waiting room. Every time a connection reads a message from a client, it turns it into a json object and drops it into the queue. 

At the moment the server is chilling and accepting connections on the main thread. So on a separate thread, we need to run a loop on to continually poll the queue and process the messages!

This is a clear separation of concerns where your Connection instances send and receive data from the clients. And the server takes all these messages and actually does stuff with them.

Let's build it!


Scene 18
Over in the server class, let's initialise the queue with Python's Queue module - it is thread safe so all our connections can write to it without stepping on each other's toes.

Next, pass it into the Connection object so the connections have access to the queue.

Of course we need to tweak the Connection __init__ to accept the queue.

Still in the Connection class, create a method called add_to_queue. We will add the tuple (self, message). 

This is so that later, when the server polls the queue, it can see who sent the message (i.e. this connection instance) as well as its contents.

We can take it for a test drive by adding the new connection's username to the message queue, after we receive it.

Over in server, let's kick of a new thread to process these messages. 

Our message processing logic will run continuously in a while True. We grab the connection who put the message in the queue, and the message itself. Because remember that's what we plonked in the queue with our add_to_queue method.

For now, let's log the message and who put it in the queue to check it's all working.

Let's try it - I sent my username, and you can see the message was received and added to the message queue in the Connection class. Then the Server polled the queue.


Scene 19
Now is a good time to go over the architecture of this game. Because your brain is probably a bit overwhelmed with all these sockets and threads.

The server is listening for and accepting connections in a loop.

A client connects. We have a new player.

When a connection is accepted, a new socket object is spawned purely for talking to that client. This is handled on a separate thread. All reading, writing, decoding logic is written in the Connection class.

When a client sends a message, like "Heyy here is my username", it is parsed and pushed to the message queue. 

The server is running a separate thread dedicated to processing messages in this message queue. This will poll the queue and perform updates based on the message received, such as adding a player or changing a snake's direction.

This is where we are up to. The last few pieces of the puzzle go like this.

The game state is essentially a big object keeping track of the entire game. For example, when the message is received that a new user has joined, the player and their username is added to the game state.

So, the game state needs to be continuously updated by the server in a loop on another thread. Because remember, the server is the source of truth for our game world. So every tick, it moves snakes forward, calculates scores, checks if someone crashed into a wall or tried to eat another snake, and updates everything accordingly.

Once updated, it broadcasts the game state to all connected clients.

On the client side, there's a loop running that's constantly receiving the game state updates, and redrawing the screen so players always see the latest version of the game world.

Finally, another thread on the client side is listening for user keypresses like the classic W A S D and sending it over to the server. So the snake can slither. 

And the cycle continues - Client sends the keypress, connection handler receives the message and adds it to the message queue, server polls the queue and updates the game state, server sends the updated game state, client redraws the screen.


Scene 20
So for the next part of our coding adventure, it's time to tackle the game state. 

Create a new file called state.py, ready with a State class. 

In the __init__ we want to initialise a few things. Firstly, the dimensions - I've gone with a height of 30 and width of 80. 

The next thing is the position of the food because these snakes are hungry. 

This should be a randomly generated position in the map. So import random and let the y-coordinate be a random number between 1 and height-2, and the x-coordinate be a random number between 1 and width-2. This is to leave some room for the border around the edge of the map.

Finally, we need to instantiate a blank dictionary of players. Essentially this will map each player's username to the information about their snake and score.

So, just to remind you where we are - the server has just received a username from a client. The Connection class parsed the message and chucked it into the message queue.

Now it's time to process that message in the process_messages loop.

Over in the Server class, we need to initialize the State. So in the server's init, create an instance of our shiny new State class.

Then when we're processing a message from the queue, if the message is a username, we'll call add_player. And hopefully now it's even clearer why we send our messages as dictionaries, because look how easy it is to tell that this is a username.

Inside add player, our State class will generate the final, unique username.

Let's do it like this: we'll take the username they sent and make sure it is unique by appending a number to it - and while the username is still taken i.e. in the dictionary of players, keep incrementing that number.

And then send the unique username back to the client. Kind of like a little digital handshake that says: "Welcome aboard, you are officially SnakeGuy2."

Of course, this means we need to create this send method in the Connection class, just like we did for the Client class. So this is a nice refresher - we use socket.sendall, and encode the message and add a newline char.

We can also set the username on the connection. Remember how the Connection class had a username property? Personally I almost forgot.

But there is one problem. We need to lock the game state while we get this unique username. But what are locks? I'm glad you asked.


Scene 21
When you've got multiple threads running - like we do in this game - you need to be very careful about shared data. In our case, the game state is one of those shared pieces of data. Multiple threads might want to read from or write to it at the same time, and things become a bit of a lottery.

And if two threads try to do that at the exact same moment? You get a race condition. 

For example, Thread A and Thread B both check the current list of players at the same time. At the time each of them checks, the username 'em' isn't there. So they both say: "Great! This username is available." And they both go ahead and add 'em' to the players list.

Then you have two players with the same name and your snakes are suddenly having an identity crisis.

To avoid this madness, we use a lock which is kind of like a Do Not Disturb sign.

Only one thread can hold the lock at a time. If a thread wants to update the game state, it first acquires the lock. Once it's done, it releases the lock so the next thread can have a go.

In this case, the first thread acquires the lock. It checks the players list - 'em' isn't there - so it adds 'em'. Now it releases the lock, and the second thread can have a go. It also wants to add 'em', but now it sees it's already taken - so it adds 'em1' instead.


Scene 22
Let's go ahead and create the lock for locking down our game state with threading.Lock(). And back in our add_player method, we can now get the unique username in peace by holding the lock with self.state_lock.

And don't forget, we then sent that unique username back to the client. Let's receive it in the Client class to complete the connection process. 

Another nice refresher about receiving data on the socket. Receive 1024 bytes, decode it, and strip the newline char.

If we didn't receive the username the server probably died so let's close everything down.

Else, the client now officially knows who it is in this multiplayer world. Let's set the username property and welcome them!


Scene 23
Of course this is all a bit useless right now since we are not actually adding the new user to the game state yet.

To keep things neat, we are going to create a Player class in the server directory. This will have all the information about this player.
- segments will store a list of coordinates of each segment of the snake's body.
- direction will store the snake's direction. 
- score is of course the score, which starts at the humble 0.
- colour is of course the colour.

In the State class, write a method to add this player to the game state.
- The first segment needs to be in a randomly generated position. Remember we already wrote this get_random_position method for randomly generating the initial food location.

I'm going to add an optional parameter to this method, which just adds a bit of a buffer so the snake doesn't generate right on the edge and die immediately.

TODO: Buffer drawing

- The initial direction can be randomly selected from W A S D. 
--> To create the directions map, I represent each of these directions as the unit vector. For example, direction 'A' is a step -1 in the x direction. Just note that curses (which is the library we will be using for the rendering), writes their coordinates in [y, x] form rather than [x, y] form. It says in the docs it's too late to change things now.
--> Remember that UP in the y direction is a step of -1, because y coordinates decrease as you move up the screen.

- Lastly, let's randomly select the colour. We are going to map each of these numbers to an actual colour when we do the rendering, so stay tuned for some colourful snakes.

Of course, we add this player to the players dictionary, with the username as the key for that O(1) access.

And don't forget - in the Server, after creating the unique username, we need to actually call the add_player method we just created.

Now we can take this for a test drive. If I make my username Em it says welcome Em and you can see it was added to the list of players.

Then if I make my username Em again, you see it appended a 1 on the end to make it unique.

Do I dare add another Em? Let's do it, you can see it appended a 2 this time.

However, notice that the client just quits immediately after receiving the unique username. That is because nothing actually happens yet - there's no game loop. 

So what we really want to do is, after receiving the unique username, start receiving the game state from the server so we can draw it.

This will involve completing that final piece of the architecture, which is the broadcast loop. This updates the game state on a loop and sends out the new game state to all connections.


Scene 24
We are ready to start braodcasting the game state to all connected clients. But hold on - do we even know who is connected? 

In the Server class, we will keep track of connections in a nice guest list.

Just like the game state, this also needs a lock because multiple threads could be adding and removing connections at the same time causing a bit of chaos.

Every time a new player connects, we append their Connection object in add_player, making sure to lock while doing it. 

It probably occurred to you when I showed myself adding the three Ems to the game, that when the client quits the program, Em is never actually removed from the connections list or game state. Like a ghost haunting your server.

So let's also create a remove player method in the State class. Pop them from the players dictionary if they are in there.

And in the Server, let's write remove_player as well to remove the player from the game state and connection list. 

Note that in the remove_player function, I only need to pass in the connection object because the username is stored smartly in that class, accessible with connection.username.

Then with the connection lock, let's remove the connection from the list. I also like to call close on the connection's socket, just in case.

But when do we need to remove the player? Think about it: The client crashes, disconnects, CTRL+C's, rage quits, whatever. I.e. In the close method of the Connection class.

But this method is in the Connection class. How can we tell the server we want to remove this player from the game state and connection pool?

That's right - the message queue!!

So in this method, add to the queue remove_connection and self. Because this connection basically wants to remove itself.

Then back in the process_message method in the server, if remove_connection is the next message, let's remove that player.

And while we're here - update the server's close method to loop through the connections and close all their sockets for a bit of spring cleaning.


Scene 25
I would say we are now getting into the fun end of the tutorial. Not that the rest of this was not fun. So if you've made it this far, let's make your hard work visible and colourful as we get the client to render the game state.

So what we need to do now is on a separate thread:
- Update the game state based on the game logic
- Broadcast the game state to all the clients.

The clients will run a loop to constantly receive the state and update the users' screens.


Scene 26
In server we need to kick off that thread. 

And in the broadcast_loop, we want two things to happen over and over:
1. Update the game state (let's leave this as a bit of a TODO for now).
2. Broadcast the updated state to all connected clients.

Our game state is essentially our State class. We can't just send this out via sockets - we need to actually convert its properties to a JSON string. 

Use json dumps to convert this dictionary of all the class properties to a JSON string.

Now for the players list, remember each of our players is also a class. I know it's annoying. So we need to convert the Player class to a dictionary too. 

Let's create that to_dict method in the Player class. Just return the dictionary of all it's class properties.

This is the structure of our dictionary that we are going to be sending to all the clients.

Just a quick pointer, we want to actually sleep before the next iteration of the loop. This is kind of an oversimplified version of a frame rate, so I'm only updating the game state every 75 ms.

Now, let's actually send the state out in the broadcast() method. This goes through every Connection in the connections list and calls .send(message).

Good news: your send() method already takes care of converting strings to bytes - so no need to encode it.

Bad news: if send() fails (e.g. socket's broken), we should remove the connection. But that's good news in disguise because our close() method already enqueues a remove_connection message.


Scene 27
Of course nothing happens yet because the client isn't set up to receive this game state. In other words, the client ends its program, the server tries sending the game state to it, and it can't. But look how nicely everything gets cleaned up!

So hop over to the client - we are going to code the main render loop.

So these game updates will come in constantly. We need to append them to a buffer. 

While we are running, receive a big chunk of data. If the data is empty, the server has closed the socket on the other side so we need to break out of there.

Otherwise, append it to the buffer. Remember all our messages are sent with a newline character on the end to break them up. 

So while the newline character is in the buffer, take the next message with .split('\n', 1) and convert it back from a JSON string to a dictionary with json.loads().

In other words this split syntax is essentially just splitting the latest message off the buffer, up to the first newline character.

So we have the game state as a dictionary, stored in state.

For now, let's just print it out.

And as an example of why we want the running flag, if say the current user is not in the players list of the game state dictionary, we want to break out of this inner loop and end the main loop.

Otherwise we should render the screen once we receive the game state.

We also want to break if we get a KeyboardInterrupt - the user ctrl C's. Or any other exception. Feel free to log whatever you want here. On the client side I just prefer minimal logging because the players of your game probably don't want to see ugly stack traces.

And finally (remember this always runs after everything is done) call close with a message like "Game over".

If we run it - check it out, the client continuously receives the game state dictionary.

Perhaps even more exciting - If I connect a second client, you can see they have been added to the game state, and that is now broadcast to all the players too. Remember this person's name will be Em1 to make it unique. 

And even MORE exciting - If one of the clients say em, quits the game, they are gracefully removed from the game state and connection pool. And you can see that in the game state of em1 who is still playing.


Scene 28
Of course a dictionary of the game state is not very epic gaming. We want to actually see it on our screens.

We are going to be using the curses library to draw this game in the terminal like a cool arcade game. 

TODO: Snake overlay

However, a benefit of this architecture is that you can use whatever library you want to take in this game state dictionary and draw it to the screen. You could use Pygame, Tkinter or even pure ASCII art - I'm not gonna to judge you.

Create a new file called render.py. And congratulations, we actually finally have all the files we need, it's smooth sailing from here!

In the __init__ of our Render class, we have a few things to pass in - the username of the current user, dimensions and the client.

Why the client? Well because we need to send over some data back to the server in the future, like keypresses, so we need the client's socket.

Then initialise stdscr which is an object representing your screen in the curses library. And the game state which is None for now.

In the client, let's store this render class. We will initialise it when we get sent the game state for the first time, because we need to pass in info like the username and dimensions.

Then in the update render method, if we haven't initialised our render class yet, it means we are receiving this game state for the first time. So we initialise the render class to draw the initial game window, and pass in the dimensions from the game state.

Feed the Render with the username, dimensions from the game state, and ourselves for the client.

Now the render engine is ready to go, from this point on when we get a new state, we'll call something like self.render.update.


Scene 29
Next we will render just a plain and simple arena for the snakes.

This is called from the init, because to put things in context, we've just passed in the game state for the first time, and we want get busy with drawing a game window.

Firstly, we want our cursor to go away or it will annoyingly follow our snake around, with curses.curs_set(0).

Then use no echo to hide our keypresses so our snake doesn't poop out a character whenever we press a key.

TODO: Show these settings not turned on

We will refresh the screen to remove any junk that might be on there.

Grab the height and width from the dimensions. Then we can draw the game arena with curses.newwin - Make it the height and width fed to us from the server. And put it in the top left corner at position 0, 0.

Give it some love put a nice border around it. And refresh it.

Very importantly - we need a cleanup method to restore our terminal. Otherwise when it closes, your cursor won't come back and your keys won't echo.

Then we will call this cleanup method whenever we close the client. But only if we've initialised the class.

The game window kind of comes up for a bit. If you blinked you might have missed it. We want to keep redrawing it.


Scene 30
In update render loop in the client, remember we receive the game state from the server on a constant loop. Pass it into an update state method in the render class.

Then create an update_state method in your render object, and pass in the new state. We're going to draw it and if it cooks itself, cleanup the screen.

TODO: Show game dict.

So let's take baby steps by drawing the food because that's just one character. The food comes in as a coordinate. We can add it to the screen with addch. This star syntax just unpacks the list, passing in the y, x coordinates. Then pass in the character itself.

And of course refresh the window each tick.

Next, add the current user's score. The score hides away in players, our username, score.

And add the score to the screen with addstr. Again this takes in y,x coordinates. We will put it in the bottom right corner, so height-1, width minus say 12. Then the string to add to the screen.

And of course when done we want to update the render's state to be this new state.

Let's run it - yay it just sits there doing nothing. But the food and score is there.


Scene 31
A few of you might be wondering why I'm only setting the new state here after I've already drawn it.

The reason is because rendering is quite an expensive operation. So rather than drawing everything in the state dictionary every frame, we are actually going to compare the new_state with the current state, and only draw what changed between the two frames. This is known as a partial redraw.

Then after it's drawn I set the current state to be the new state. So the cycle continues.

To demonstrate, I wrote a version of the code which wipes the screen and redraws everything every tick. It flickers in this very distracting way. So, partial redraws are the way to go.

With that in mind let's give an example with the user's score and only redraw the score:
- if self.state is None, meaning this is the first draw
- Or if the new score is not equal to the current score - players, our username, score.


Scene 32
This next part is exciting - rendering the snake.

Create a new method called draw_snakes and pass in the snakes.

For each snake in our new snakes list:
- Set current snake to be empty by default.

--> Unless the current snake exists already, as in this isn't our first draw (self.state is not None) or this user hasn't only just joined, as in they are in the current state's players dict. In that case, set it to be the current snake in the game state for this user.

- Now we are going to only draw the differences between the current snake and new snake in update_snake. Remember the snakes are represented as a list of segments.

In general every snake will have one head added on and the tail popped off for each step. 

But to be safe, we'll do this in a loop to make sure we get all the segments. Loop forwards through the new snake starting from the head. If this segment is not in the current state, draw it to the screen.

And if it is in the current state, we can stop the loop because that's all for the new segments.

Then do the same for the tails - loop backwards through the current snake. If this segment is not in the new state, remove it space. And if it is in the new state, we can stop the loop.

So here goes our forward loop: 
1. Loop through the new snake's segments while this segment isn't in the current snake.
2. Add the new segment to the screen with addch. I use this cool checkerboard character for the body.

Then go backwards:
1. Loop through the current snake's segments while this segment is not in the new snake.
2. Remove the old segment from the screen with addch, but using a space.

Looking good! There is our little start segment.

And if we bring a second player into this, you can see their little start segment too.

One problem though - If one of the players leaves, you can see in the server logs they have left the game. So why is their snake still haunting the screen?


Scene 33
I will flash up the code again and see if you can figure it out.

The answer is because we are only looping through the players in the new state, and updating their snakes.

However, if someone leaves the game they are booted from this dictionary. This is a classic multiplayer gotcha.

So we need to loop through the players in the current state too. If they are not in the new state it means they have died. So let's update their snake to be the empty snake, wiping them from the screen.

Here we go player 1 is on the screen. Now player 2. Now let's get player 1 to quit. You see he has been removed from player 2's screen.

Happy days. 


Scene 34
The observant among you might realise that these snakes aren't exactly moving. They're a bit lazy.

That is because back in the server, we are sending the state out constantly, but we never actually update the game state each frame. All we do at the moment is add new players, give them a random start location, and remove players who have quit the game.

So we are essentially spamming the clients with unchanged data.

Let's write code for the main engine - updating the game state on the server side. This will all be done in the State class.

If you're a bit of an emcapsulation fan, you will remember back to about 4 weeks ago I released this bad boi video about writing a snake game in under 50 lines of Python.

TODO: Show clip from that video.

Essentially we are going to take the logic in those 49 lines of code, and plonk it here. Minus any logic about getting user keypresses because the client needs to send that over. And minus any logic about rendering it to the screen, because the client will be doing that.

TODO: Slowly remove lines from the screenshot.

Let's get stuck in.


Scene 34
To simulate movement, a naive way would be to loop through every segment in the segments list from tail to head, and update all these segment pieces to be the position of the segment in front of it. And for the last segment, the head, nudge it in the direction of the snake's motion. 

Then redraw the snake on the screen.

But this is expensive and will take unecessary lines. 

Instead, notice that after one step or slither I guess, this grey section is identical between both snakes. So all we actually need to do to move the snake one step is pop the tail off and add the new head on in the direction of motion.

So the tail and the head only two segments we need to consider in each step. We don't need to touch the other segments.


Scene 35
So for each snake, add the new head on in the direction of motion. This can be done inside the Player class, which deals with this part of the game state dict.

Then we will pop the tail. Let's write both these methods over in the player class.

TODO: Highlight dict structure

Before we add the new head, let's get the position of the current head. This is the first coordinate of the segments list. And if we pass in the optional parameter j, let's actually return the x or y coordinate from the head. This will be useful later.

Then to add the new head, remember we use these unit vectors for the direction. So simply add the unit vector of the current direction to the current head to nudge it one step in that direction.

Insert the new head at the beginning of the segments list.

To pop the tail, this can be done with self.segments.pop() to just remove the last segment.

The big reveal - yes our snake is in motion!

Unfortunately he can wander off and kill the game.


Scene 36
Let's fix that. After we add the new head on, let's check if he survived the move. Pass in the dimensions of the wall.

Over in the Player class, if our head's y coordinate hits 0 or height-1, or our x coordinate hits 0 or width-1, return False because he did not make it.

If he did die, we can't really just remove him here because we are still in the middle of looping through this dictionary. So instead, add him to an eliminated players list. 

continue just means we are done with this snake don't bother doing the rest of this iteration because he died.

Then after the loop, go through the eliminated players list, and remove each player. Remember this remove method removes this player from the list.

This new game state will be sent to that client, and they are not in the list anymore, so they will close their socket and end the game on their side.

And then the server will clean them up when it sees the closed socket.

Quick check - Yep you can see in the logs he hit the wall, he got removed from the list of players, and the server removed them from the connection pool when it couldn't send the next game state to them.


Scene 37
Unfortunately, we don't want to just join the game and collide with a wall. So let's set up being able to change our direction with the class gamer keys: WASD.

The client is doing all the hard work rendering the screen in a loop. But we want to also capture keypresses at the same time this render loop is going on. 

How do we deal with this? That's right threads you're learning!

We make a new thread for capturing the user keypress. And we will start it after we initialise the render - so basically as soon as we first draw the game window.

We need this inside our render class because we will be using curses.

In a while True, we'll use self.stdscr.getch() to get the user's keypress.

getch returns the ASCII code of the key you pressed. So let's check if it's a valid key, W A S or D, by comparing it to the ASCII values of these characters with ord.

If so, we need to send this keypress over to the server, which is why we needed to pass in the client to the render class.

But don't forget, we send these messages over as a dictionary so the server knows what the heck it just received.

I also apply this setting: timeout(75). This means that getch only waits 75 ms to get the character input from the user, before the loop moves on with its life and loops again.

And of course, finish by calling the cleanup method.

Our handle method in our connection class has been twiddling its thumbs a bit because the client hasn't sent anything over yet. Now it's ready to receive these keypresses. 

We will do something similar to the update render code, where we append the new messages to a buffer and process them one at a time.

So nice little refresher here.

1. Receive a chunk of data and decode it.
2. If no data was received, break out of the loop because the client probably quit.
3. Otherwise, append the data chunk to the buffer.
4. Then constantly grab the next complete message from the buffer by slicing up to the first '\n' char.

Convert it back to a dictionary with parse_message. And add it to the message queue so the server can process it.

Let's quickly check that our keypresses are being sent over and yep you can see them in the logs.

They don't change his direction yet though.


Scene 38
To make him change direction, pop this message off the message queue and process it. 

We just want to update the direction of the player who sent the message, connection.username.

In the state class we have these keys mapped to their directions. 

I know before we were mapping the ASCII codes to the directions with ord, but now the client sends across the character. So let's just map the characters. Sorry.

Then you will also need to delete ord from the random direction it gets in add_player.

Update the player's direction. First, check player exists and they gave a valid key because we love defensive programming here.

Then grab the player from the players dictionary, and the new direction from the DIRECTION_MAP.

And all we need to do is set this player's direction to the new direction.

Note that we don't need to insert the new head here because the update game state method already does that, and that's on a constant loop.

We just update the direction. Then the update game state method will plonk the new head on in that direction in its next iteration.

But we do need that fancy lock. Otherwise our snake might start doing the worm.

The big reveal - ok I died straight away that's a skill issue. And look! I can move my snake around.

Then he can move but he can also wiggle in this crazy way, he shouldn't be able to move left directly to right or up directly to down.

If two directions are opposites, notice that their unit vectors add to the 0 vector, [0, 0]. 

So let's only update his direction if that's not the case.

Add the two vectors, they are opposites if they add to == [0, 0]. Again let's not update the direction if this is the case.

Now notice in the logs I'm pressing the A key to try and move left and I can't. My snake can no longer defy physics.

Congrats you've finished the server code!


Scene 39
Unfortunately nothing happens when he eats the food yet, so he has the world's fastest metabolism. Must be nice. 

When he eats the food, he should grow.

Remember in each step we add on the new head and pop the tail. Well how about, to simulate growth, we simply don't pop the tail when he eats the food. The new head still gets put on though, so he gets one segment longer.

So in your update state method, if his head is not eating food, pop the tail like normal.

Otherwise, increment his score. Celebrate the small wins.

Now he can eat it but the food doesn't really move around which is a bit too easy. We're out here just accumulating points.


Scene 40
Let's fix that. Store who ate the food in eater. And set it to the user who ate the food.

Now after the loop, if someone got the food, we want to regenerate it in a different spot. And we also want to increment the eater's score, so pass that in. We'll be a bit naughty and do it all in the same function.

Get a random position for the food. And increment the eater's score. Oh yeah and write self lol.

Anyway I just wanted to flex that I reached a score of 100. Which is kind of sad more than anything since I already had code for the singleplayer version in 49 lines of code, from my previous video. Shameless self promotion.

But while I was playing I noticed that the snake can move through itself like this.

Then, in some rare cases which I didn't get on video and will probably never happen again, the food actually generates on the snake's body. Let's fix both of these.


Scene 41
We don't want the food to generate on any segments of any snakes.

Let's make an epic list of all segments called occupied_positions. Then loop through the players dictionary and add everyone's segments to it with extend.

And, generate this list when we update the state.

Now when we regenerate the food, we have awareness of where not to go. So while the food generates on a snake's body, just keep moving it around.

However, there is another use for this occupied positions list. In snake we don't just die from hitting a wall. We also die from hitting ourselves. And in multiplayer snake, we die from hitting another snake too. 

TODO: Drawing of snake death.

So back in check_is_alive, pass in the list of segments. Because our snake should die if its head hits any of these segments too.

The big reveal - he coils but he twist himself! And in the logs it says he collided with a segment.

Now I know what you're probably thinking - this is supposed to be multiplayer snake and all you've shown us is singleplayer.

And honestly fair criticism. It's just a bit of a steep ask of my family to play multiplayer snake with me for hours while I test each new method I write.

So here is me switching between two terminals really fast, to show you collisions with other snakes.

Ok first snake is in. Second snake. Wow em got the food. Now time this right and I should get a collision. What epic play.


Scene 42
All these grey snakes are a bit boring. It's also impossible to tell who is who.

Let's spice it up a bit with some colours.

You might remember from earlier we had this list of colours from 1 to 7, and we selected a random colour from this list to give to our player. 

I decided this was a bit silly when you can just select a random number from 1 to 7.

You're probably thinking "those aren't colours". Well to the computer they are. Because we create these colour mappings in our render class.

The first item is the foreground and the second item is the background. Lots of good colours there.

Now when we create the game window, we want to use curses.start_color to tell the terminal to get colourful.

Then for each mapping in our colour map, call init_pair which basically hooks that number from 1 to 7 up to the respective colour.

The curses library experts among you might realise that curses already comes with default colour pairs, but I'm showing you here how to override it, in case you want some of your own colour schemes.

Of course this has just initialised the colours. We want to now apply these colours everywhere we draw the snakes.

The update_snake function is a good start. Pass in the colour.

Then in addch, in a bit of a twist, you can pass in the colour, with curses.color_pair(your colour).

Now in draw_snakes where we call update_snake, we need to pass in the colour of the snake we're drawing. We can just grab that from our dictionary.

The big reveal... Wow and the first one just happened to be white which is like a 1 in 7 chance how boring.

Ah and the second one is this nice blue colour or CYAN for the terminal colour fans amongst us.

Anyway here is some more footage of the multitude of vibrant colours. While I frantically switch between terminals.

But you can see that when someone scores, only they can see their score increment. The last feature we will implement is the leaderboard, so you can flex your score on everyone else in the arena.


Scene 43
The leaderboard will kind of be off to the side of the main window. So give it a width of 15.

And in create_game_window, essentially we are going to do everything we did for the main window, and copy it for the leaderboard. Because in curses, you can make multiple windows and position them around the terminal.

Except give it a new name. It's height will be the same as our normal window. But it's width will be skinnier.

Then its position won't be 0, 0 (the top left corner). It's position will be next to the main window. As in its y coordinate will be 0, but its x coordinate will be self.width+1 to push it that much to the right.

Then everything else will be the same. Except we will give it a fancy title at the top there.

So the thing with creating new windows in curses, is that now I can say put the LEADERBOARD title at position 1, 1 - And it now means the top left corner of this leaderboard window, not the entire terminal.

Now inside draw we need to draw the leaderboard, and pass in the snakes.

Firstly, for each player in the dictionary, we will write their name and score with addstr. We need to start at the y coordinate 2 because remember we have 0 taken up by the border, and 1 taken up by the heading. And x coordinate can be 1, again for the border.

We need to do a bit of formatting when we actually write the name and score though, because some people might have long names which need truncating and so on.

We'll let another function take care of that. Pass in the username and score.

And pass in the colour of this snake into addstr. So the leaderboard can be the same colour as the snakes.

Don't forget to increment i (our y coordinate) or all the leaderboard strings will be written on top of each other.

To format this string, I wanted the username on the left, then the score on the right. 

Our total length is the leaderboard width minus 2 to account for the border.

Then the max length our username can be is the total length, minus the length of our score, minus 1 for the space between the username and our score.

If the username is longer than this, truncate it to username_length minus 3, because we will put ellipsis in those last three chars.

If the username is a fine length, we will just use the full username. 

Now calculate the number of spaces between the username and the score. That is the total length, minus the length of the username, minus the length of the score.

Then finally our formatted string is the truncated username, plus the calculated number of spaces, plus the score.

And of course, call self.leaderboard_win.refresh() so these changes show up.

I'm going to play by myself a bit to demo the leaderboard. And look at that! However, snakeboi just died but he didn't get removed from the leaderboard so that's bug number 1.

But number 2 is that if someone overtakes someone, they aren't moved up the leaderboard.


Scene 44
We can fix this by cleaning up dead players.

Define the dictionary of current players as empty if the game state is None (as in we are on our first draw). Else, the players dict.

The number of entries in the leaderboard we need to remove is the difference between the sizes of these two dictionaries.

And this is the y coordinate we're wiping out. And we are just putting in the empty string so we can use format_leaderboard_string but use empty strings for the username and score, essentially wiping it.

Then decrement to_remove, since we need to remove one less entry now.

Our second bug was that the leaderboard isn't sorted. That's ok, over in our update game state code on the server side, we can sort the leaderboard if someone ate the food. Because that means the scores are different.

So we are going to sort the players dictionary. items means I want to rearrange the key, value pairs.

key is what we are sorting based on. In this case we are sorting based on the player's score.

Then reverse=True means we want it in descending order, because we want the winning snakes at the top.

Here we have a snake showdown. And you just saw yellow overtake red and the scores re-sorted. Then red died and he was removed from the screen!


Scene 44
This game is so awesome I just know all your friends and entire extended family will want to play.

But they can't. Because the server host is hardcoded in as 127.0.0.1 - our localhost - so the server only accepts connections from the same machine.

Let's change this. Changing this to 0.0.0.0 tells the server to listen on any of its network interfaces - Wifi, ethernet, dial-up modem (just kidding).

We can output your local server IP address so you know what to tell your family on Discord. This IP address will work for people on your same home network.

socket.gethostname gets your computer's device name, you've probably seen it, because it's usually like DESKTOP then a bunch of cryptic letters.

Then socket.gethostbyname takes your device name, and resolves it to an IP address.

Now take note - this might still print out 127.0.0.1. Because to resolve your device's IP address it tries looking up your device name in your hosts file or the DNS server in your router, and it might not find it. 

So to figure out what your local IP address is:
On Windows, use the command ipconfig and look for the IPv4 address in the Wireless LAN section or Ethernet section if that's your style.
On Mac and Linux, use the command ifconfig and look for the inet address in the section corresponding to the interface you want.

A second note is that VM's kind of live in their own little networking bubble so I wouldn't run the server on a VM as they may not be reachable by other devices in your LAN, unless you are willing to do a little bit of setup.

Now when you run the server, share this local IP address and port with your family on your local network to let the games begin.


Scene 45
If you want to make your snake game available outside your home network, you will need to do port forwarding. But warning: I wouldn't really attempt this unless you kind of know what you're doing and you're aware of the risks.

Essentially, your router is kind of acting like a bouncer. You have this public IP address. Then inside your LAN, you have all your fam's devices, and each device has a different private IP address. 

So if someone tries to join your snake game by connecting to your public IP address and port 5050, your router gets a bit confused because how is it meant to know what device should receive it?

When you use port forwarding, you are mapping a port on your public IP address to your own device essentially. In other words, you can say "Hey anyone connecting to our public IP address on this port, send them over to my snake game".

Your router keeps track of this in its NAT table. Now your game is reachable from outside your home network!


Scene 46
If you have made it this far through the video, I just wanted to thank you - This is stuff isn't easy, you've learned advanced concepts like sockets, multithreading, message queues, and partial rendering.

But I haven't finished the video yet and I can already hear the comments. So now I'm going to tell you why this game is a bit cringe. (Aka the postmortem that should have been the design doc).


Scene 47
The first major issue is scalability. The server creates a new thread for dealing with each client. This was fine when I was playing with my mum and brother. But not if you post your IP address in your Discord and at Everyone and 100 of you try to hop on.

This is because threads don't exactly grow on trees. Each time you spawn a thread, you need stack memory and CPU time for context switching. 

The problem is especially bad in Python - only one thread can actually execute Python bytecode at a time because Python itself has a Global Interpreter Lock - even on crazy multi-core processors.

Something you could look into would be event loop architecture like asyncio. This uses a single thread. But if there is part of the code which can be awaited, it will switch control to run other parts of the code. 

So for example, in our listen loop in the Server we called accept to accept connections. If someone connected, we would kick of a new thread to handle it, so the server could keep listening for more connections concurrently.

With the event loop architecture, you would await this new connection, but run other parts of the code in the meantime, all on a single thread. So it is more like your one thread is switching between different coroutines, and only resumes one when the thing it's waiting for becomes available.


Scene 48
Issue number two is the fact that the server is doing the very heavy task of updating the entire game state and sending it out to all clients. And the clients need to continually receive the game state to draw every frame.

For example, imagine you press the W key. It takes 50 ms to reach the server. The server updates your player in the game state to have this new direction, and pops the new head on. It takes 50 ms to return to you. 

That's kind of noticeable lag when you press a key.

Can the client do some of the work in updating the game state?

This is one of the most interesting questions in multiplayer game development - and if you're curious, I really recommend going down that rabbit hole. Because yes, the client can help, and most real games do this.

For example, the when you press the W key, the client could actually move you upwards, so there would be no lag. Then when the next game state comes from the server, the client could sync up with the game state to make sure everything matches, and correct anything that doesn't.


Scene 49
Other things you could try and correct include:
- Better cleaning up of threads
- Optimising the get_occupied_positions function
- Rather than sending the entire game state, just send the delta


Scene 50
And that's it, thank you so much, I'll put the link to all this code in the description. But for now watch me play and fail horribly against some bots I coded!